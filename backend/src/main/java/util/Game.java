package util;
/**
 * This class represents a Game.
 *
 * @author Christian Wendlinger
 */

import NetworkStandard.Characters.Character;
import NetworkStandard.Characters.CharacterInformation;
import NetworkStandard.DataTypes.Gadgets.ActionHandler;
import NetworkStandard.DataTypes.Gadgets.Gadget;
import NetworkStandard.DataTypes.MatchConfig.Matchconfig;
import NetworkStandard.DataTypes.Operations.BaseOperation;
import NetworkStandard.DataTypes.Szenario.Scenario;
import NetworkStandard.DataTypes.Szenario.State;
import util.communication.MessageEmitter;
import util.communication.MessageReceiver;
import util.logic.ingame.GameHandler;
import util.logic.pregame.EquipmentPhase;
import util.logic.pregame.ItemChoicePhase;

import java.time.Instant;
import java.util.*;

public class Game {
    private UUID sessionId;
    private List<User> players;
    private List<User> viewers;
    private Scenario level;
    private Matchconfig settings;
    private CharacterInformation[] character_settings;
    private boolean isActive;

    public MessageEmitter emitter;
    public MessageReceiver receiver;

    // for choosing phase
    private List<Gadget> allGadgets;

    // for the rest of the game
    private List<Character> allCharacters = new LinkedList<>();
    private List<Character> npcs;

    // player1 choices
    private List<Character> playerOneCharacters = new LinkedList<>();
    private List<Gadget> playerOneGadgetChoices = new LinkedList<>();

    // player2 choices
    private List<Character> playerTwoCharacters = new LinkedList<>();
    private List<Gadget> playerTwoGadgetChoices = new LinkedList<>();

    // help to choose
    private Set<Character> playerOneCharOffer = new HashSet<>();
    private Set<Character> playerTwoCharOffer = new HashSet<>();
    private Set<Gadget> playerOneGadgetOffer = new HashSet<>();
    private Set<Gadget> playerTwoGadgetOffer = new HashSet<>();

    //observed characters
    private List<Character> playerOneObservedCharacters;
    private List<Character> playerTwoObservedCharacters;

    // spied NPCs
    private List<Character> playerOneSpiedNPCs = new LinkedList<>();
    private List<Character> playerTwoSpiedNPCs = new LinkedList<>();

    // amount of available safes and a list for spy reasons
    private Integer safeCount;
    private List<Integer> safeCountIntoList = new LinkedList<>();


    public boolean[] ready = new boolean[2];

    // track the offers internally
    private int offerNr = 1;

    // all handlers that the game needs
    private ItemChoicePhase itemChoicePhase;
    private EquipmentPhase equipmentPhase;
    private GameHandler gameHandler;
    private ActionHandler actionHandler;

    // storing safe combinations and already opened safes
    private State state;
    private Set<Integer> playerOneSafeCombinations = new HashSet<>();
    private Set<Integer> playerTwoSafeCombinations = new HashSet<>();

    private Set<Integer> playerOneOpenedSafes = new HashSet<>();
    private Set<Integer> playerTwoOpenedSafes = new HashSet<>();

    private List<BaseOperation> currentOperations = new LinkedList<>();

    // information about the game
    private boolean isPaused;

    private Date gameStart;
    private Date gameEnd;


    /**
     * Constructor.
     *
     * @param sessionId          generated by server.
     * @param players            exactly 2
     * @param viewers            no limit
     * @param level              - generated by editor
     * @param settings           - generated by editor
     * @param character_settings - generated by editor
     */
    public Game(UUID sessionId, List<User> players, List<User> viewers, Scenario level, Matchconfig settings, CharacterInformation[] character_settings) {
        this.sessionId = sessionId;
        this.players = players;
        this.viewers = viewers;
        this.level = level;
        this.settings = settings;
        this.character_settings = character_settings;

        this.isActive = true;

        this.emitter = new MessageEmitter(this, players, viewers);
        this.receiver = new MessageReceiver(this);

        try {
            this.allGadgets = Gadget.generateAllGadgets();
            this.npcs = Character.generateCharacters(this.character_settings);
            allCharacters.addAll(npcs);
            this.playerOneObservedCharacters = new LinkedList<>();
            this.playerTwoObservedCharacters = new LinkedList<>();
        } catch (Exception e) {
            e.printStackTrace();
        }

        this.itemChoicePhase = new ItemChoicePhase(this);
        this.equipmentPhase = new EquipmentPhase(this);
        this.gameHandler = new GameHandler(this);
    }

    /**
     * Getter and Setter.
     */
    public UUID getSessionId() {
        return sessionId;
    }

    public void setSessionId(UUID sessionId) {
        this.sessionId = sessionId;
    }

    public List<User> getPlayers() {
        return players;
    }

    public void setPlayers(List<User> players) {
        this.players = players;
    }

    public List<User> getViewers() {
        return viewers;
    }

    public void setViewers(List<User> viewers) {
        this.viewers = viewers;
    }

    public Scenario getLevel() {
        return level;
    }

    public void setLevel(Scenario level) {
        this.level = level;
    }

    public Matchconfig getSettings() {
        return settings;
    }

    public void setSettings(Matchconfig settings) {
        this.settings = settings;
    }

    public CharacterInformation[] getCharacter_settings() {
        return character_settings;
    }

    public void setCharacter_settings(CharacterInformation[] character_settings) {
        this.character_settings = character_settings;
    }

    public boolean isActive() {
        return isActive;
    }

    public void setActive(boolean active) {
        isActive = active;
    }

    public List<Gadget> getAllGadgets() {
        return allGadgets;
    }

    public void setAllGadgets(List<Gadget> allGadgets) {
        this.allGadgets = allGadgets;
    }

    public List<Character> getAllCharacters() {
        return allCharacters;
    }

    public void setAllCharacters(List<Character> allCharacters) {
        this.allCharacters = allCharacters;
    }

    public List<Character> getNpcs() {
        return npcs;
    }

    public void setNpcs(List<Character> npcs) {
        this.npcs = npcs;
    }

    public List<Character> getPlayerOneCharacters() {
        return playerOneCharacters;
    }

    public void setPlayerOneCharacters(List<Character> playerOneCharacters) {
        this.playerOneCharacters = playerOneCharacters;
    }

    public List<Gadget> getPlayerOneGadgetChoices() {
        return playerOneGadgetChoices;
    }

    public void setPlayerOneGadgetChoices(List<Gadget> playerOneGadgetChoices) {
        this.playerOneGadgetChoices = playerOneGadgetChoices;
    }

    public List<Character> getPlayerTwoCharacters() {
        return playerTwoCharacters;
    }

    public void setPlayerTwoCharacters(List<Character> playerTwoCharacters) {
        this.playerTwoCharacters = playerTwoCharacters;
    }

    public List<Gadget> getPlayerTwoGadgetChoices() {
        return playerTwoGadgetChoices;
    }

    public void setPlayerTwoGadgetChoices(List<Gadget> playerTwoGadgetChoices) {
        this.playerTwoGadgetChoices = playerTwoGadgetChoices;
    }

    public Set<Character> getPlayerOneCharOffer() {
        return playerOneCharOffer;
    }

    public void setPlayerOneCharOffer(Set<Character> playerOneCharOffer) {
        this.playerOneCharOffer = playerOneCharOffer;
    }

    public Set<Character> getPlayerTwoCharOffer() {
        return playerTwoCharOffer;
    }

    public void setPlayerTwoCharOffer(Set<Character> playerTwoCharOffer) {
        this.playerTwoCharOffer = playerTwoCharOffer;
    }

    public Set<Gadget> getPlayerOneGadgetOffer() {
        return playerOneGadgetOffer;
    }

    public void setPlayerOneGadgetOffer(Set<Gadget> playerOneGadgetOffer) {
        this.playerOneGadgetOffer = playerOneGadgetOffer;
    }

    public Set<Gadget> getPlayerTwoGadgetOffer() {
        return playerTwoGadgetOffer;
    }

    public void setPlayerTwoGadgetOffer(Set<Gadget> playerTwoGadgetOffer) {
        this.playerTwoGadgetOffer = playerTwoGadgetOffer;
    }

    public int getOfferNr() {
        return offerNr;
    }

    public void setOfferNr(int offerNr) {
        this.offerNr = offerNr;
    }

    public ItemChoicePhase getItemChoicePhase() {
        return itemChoicePhase;
    }

    public void setItemChoicePhase(ItemChoicePhase itemChoicePhase) {
        this.itemChoicePhase = itemChoicePhase;
    }

    public EquipmentPhase getEquipmentPhase() {
        return equipmentPhase;
    }

    public void setEquipmentPhase(EquipmentPhase equipmentPhase) {
        this.equipmentPhase = equipmentPhase;
    }

    public GameHandler getGameHandler() {
        return gameHandler;
    }

    public void setGameHandler(GameHandler gameHandler) {
        this.gameHandler = gameHandler;
    }

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }

    public Set<Integer> getPlayerOneSafeCombinations() {
        return playerOneSafeCombinations;
    }

    public void setPlayerOneSafeCombinations(Set<Integer> playerOneSafeCombinations) {
        this.playerOneSafeCombinations = playerOneSafeCombinations;
    }

    public Set<Integer> getPlayerTwoSafeCombinations() {
        return playerTwoSafeCombinations;
    }

    public void setPlayerTwoSafeCombinations(Set<Integer> playerTwoSafeCombinations) {
        this.playerTwoSafeCombinations = playerTwoSafeCombinations;
    }

    public ActionHandler getActionHandler() {
        return actionHandler;
    }

    public void setActionHandler(ActionHandler actionHandler) {
        this.actionHandler = actionHandler;
    }

    public List<BaseOperation> getCurrentOperations() {
        return currentOperations;
    }

    public void setCurrentOperations(List<BaseOperation> currentOperations) {
        this.currentOperations = currentOperations;
    }

    public List<Character> getPlayerOneObservedCharacters() {
        return playerOneObservedCharacters;
    }

    public void setPlayerOneObservedCharacters(List<Character> playerOneObservedCharacters) {
        this.playerOneObservedCharacters = playerOneObservedCharacters;
    }

    public List<Character> getPlayerTwoObservedCharacters() {
        return playerTwoObservedCharacters;
    }

    public void setPlayerTwoObservedCharacters(List<Character> playerTwoObservedCharacters) {
        this.playerTwoObservedCharacters = playerTwoObservedCharacters;
    }


    public boolean isPaused() {
        return isPaused;
    }

    public void setPaused(boolean paused) {
        isPaused = paused;
    }

    public Date getGameStart() {
        return gameStart;
    }

    public void setGameStart(Date gameStart) {
        this.gameStart = gameStart;
    }

    public Date getGameEnd() {
        return gameEnd;
    }

    public void setGameEnd(Date gameEnd) {
        this.gameEnd = gameEnd;
    }

    public Set<Integer> getPlayerOneOpenedSafes() {
        return playerOneOpenedSafes;
    }

    public void setPlayerOneOpenedSafes(Set<Integer> playerOneOpenedSafes) {
        this.playerOneOpenedSafes = playerOneOpenedSafes;
    }

    public Set<Integer> getPlayerTwoOpenedSafes() {
        return playerTwoOpenedSafes;
    }

    public void setPlayerTwoOpenedSafes(Set<Integer> playerTwoOpenedSafes) {
        this.playerTwoOpenedSafes = playerTwoOpenedSafes;
    }

    public List<Character> getPlayerOneSpiedNPCs() {
        return playerOneSpiedNPCs;
    }

    public void setPlayerOneSpiedNPCs(List<Character> playerOneSpiedNPCs) {
        this.playerOneSpiedNPCs = playerOneSpiedNPCs;
    }

    public List<Character> getPlayerTwoSpiedNPCs() {
        return playerTwoSpiedNPCs;
    }

    public void setPlayerTwoSpiedNPCs(List<Character> playerTwoSpiedNPCs) {
        this.playerTwoSpiedNPCs = playerTwoSpiedNPCs;
    }

    public Integer getSafeCount() {
        return safeCount;
    }

    public void setSafeCount(Integer safeCount) {
        this.safeCount = safeCount;
    }

    public List<Integer> getSafeCountIntoList() {
        return safeCountIntoList;
    }

    public void setSafeCountIntoList(List<Integer> safeCountIntoList) {
        this.safeCountIntoList = safeCountIntoList;
    }

    /**
     * equals and hashCode
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Game game = (Game) o;
        return isActive() == game.isActive() &&
                getOfferNr() == game.getOfferNr() &&
                Objects.equals(getSessionId(), game.getSessionId()) &&
                Objects.equals(getPlayers(), game.getPlayers()) &&
                Objects.equals(getViewers(), game.getViewers()) &&
                Objects.equals(getLevel(), game.getLevel()) &&
                Objects.equals(getSettings(), game.getSettings()) &&
                Arrays.equals(getCharacter_settings(), game.getCharacter_settings()) &&
                Objects.equals(emitter, game.emitter) &&
                Objects.equals(receiver, game.receiver) &&
                Objects.equals(getAllGadgets(), game.getAllGadgets()) &&
                Objects.equals(getAllCharacters(), game.getAllCharacters()) &&
                Objects.equals(getNpcs(), game.getNpcs()) &&
                Objects.equals(getPlayerOneCharacters(), game.getPlayerOneCharacters()) &&
                Objects.equals(getPlayerOneGadgetChoices(), game.getPlayerOneGadgetChoices()) &&
                Objects.equals(getPlayerTwoCharacters(), game.getPlayerTwoCharacters()) &&
                Objects.equals(getPlayerTwoGadgetChoices(), game.getPlayerTwoGadgetChoices()) &&
                Objects.equals(getPlayerOneCharOffer(), game.getPlayerOneCharOffer()) &&
                Objects.equals(getPlayerTwoCharOffer(), game.getPlayerTwoCharOffer()) &&
                Objects.equals(getPlayerOneGadgetOffer(), game.getPlayerOneGadgetOffer()) &&
                Objects.equals(getPlayerTwoGadgetOffer(), game.getPlayerTwoGadgetOffer()) &&
                Arrays.equals(ready, game.ready) &&
                Objects.equals(getItemChoicePhase(), game.getItemChoicePhase()) &&
                Objects.equals(getEquipmentPhase(), game.getEquipmentPhase()) &&
                Objects.equals(getGameHandler(), game.getGameHandler()) &&
                Objects.equals(getState(), game.getState()) &&
                Objects.equals(getPlayerOneSafeCombinations(), game.getPlayerOneSafeCombinations()) &&
                Objects.equals(getPlayerTwoSafeCombinations(), game.getPlayerTwoSafeCombinations());
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(getSessionId(), getPlayers(), getViewers(), getLevel(), getSettings(), isActive(), emitter, receiver, getAllGadgets(), getAllCharacters(), getNpcs(), getPlayerOneCharacters(), getPlayerOneGadgetChoices(), getPlayerTwoCharacters(), getPlayerTwoGadgetChoices(), getPlayerOneCharOffer(), getPlayerTwoCharOffer(), getPlayerOneGadgetOffer(), getPlayerTwoGadgetOffer(), getOfferNr(), getItemChoicePhase(), getEquipmentPhase(), getGameHandler(), getState(), getPlayerOneSafeCombinations(), getPlayerTwoSafeCombinations());
        result = 31 * result + Arrays.hashCode(getCharacter_settings());
        result = 31 * result + Arrays.hashCode(ready);
        return result;
    }

    /**
     * toString
     */
    @Override
    public String toString() {
        return "Game{" +
                "sessionId=" + sessionId +
                ", players=" + players +
                ", viewers=" + viewers +
                ", level=" + level +
                ", settings=" + settings +
                ", character_settings=" + Arrays.toString(character_settings) +
                ", isActive=" + isActive +
                ", emitter=" + emitter +
                ", receiver=" + receiver +
                ", allGadgets=" + allGadgets +
                ", allCharacters=" + allCharacters +
                ", npcs=" + npcs +
                ", playerOneCharacters=" + playerOneCharacters +
                ", playerOneGadgetChoices=" + playerOneGadgetChoices +
                ", playerTwoCharacters=" + playerTwoCharacters +
                ", playerTwoGadgetChoices=" + playerTwoGadgetChoices +
                ", playerOneCharOffer=" + playerOneCharOffer +
                ", playerTwoCharOffer=" + playerTwoCharOffer +
                ", playerOneGadgetOffer=" + playerOneGadgetOffer +
                ", playerTwoGadgetOffer=" + playerTwoGadgetOffer +
                ", playerOneObservedCharacters=" + playerOneObservedCharacters +
                ", playerTwoObservedCharacters=" + playerTwoObservedCharacters +
                ", playerOneSpiedNPCs=" + playerOneSpiedNPCs +
                ", playerTwoSpiedNPCs=" + playerTwoSpiedNPCs +
                ", safeCount=" + safeCount +
                ", safeCountIntoList=" + safeCountIntoList +
                ", ready=" + Arrays.toString(ready) +
                ", offerNr=" + offerNr +
                ", itemChoicePhase=" + itemChoicePhase +
                ", equipmentPhase=" + equipmentPhase +
                ", gameHandler=" + gameHandler +
                ", actionHandler=" + actionHandler +
                ", state=" + state +
                ", playerOneSafeCombinations=" + playerOneSafeCombinations +
                ", playerTwoSafeCombinations=" + playerTwoSafeCombinations +
                ", playerOneOpenedSafes=" + playerOneOpenedSafes +
                ", playerTwoOpenedSafes=" + playerTwoOpenedSafes +
                ", currentOperations=" + currentOperations +
                ", isPaused=" + isPaused +
                ", gameStart=" + gameStart +
                ", gameEnd=" + gameEnd +
                '}';
    }

    /**
     * Add a player to the Game if the Player count is less than 2.
     *
     * @param player - Player to add
     * @return true if player could be added, false else
     */
    public boolean addPlayer(User player) {
        if (players.size() < 2) {
            players.add(player);

            emitter.setClients(players);
            return true;
        }
        return false;
    }

    /**
     * Remove a player from the Game.
     *
     * @param player - Player to remove
     * @return true if player is in the game, false else
     */
    public boolean removePlayer(User player) {
        if (players.contains(player)) {
            players.remove(player);
            emitter.setClients(players);
            return true;
        }
        return false;
    }

    /**
     * Viewer MAX_COUNT can be added later.
     * <p>
     * Add a Viewer to the Game.
     *
     * @param viewer - Viewer to add
     * @return true if viewer could be added, false else
     */
    public boolean addViewer(User viewer) {
        viewers.add(viewer);
        emitter.setViewers(viewers);
        return true;
    }

    /**
     * Remove a viewer from the Game.
     *
     * @param viewer - Viewer to remove
     * @return true if viewer is in the game, false else
     */
    public boolean removeViewer(User viewer) {
        if (players.contains(viewer)) {
            players.remove(viewer);
            emitter.setViewers(viewers);
            return true;
        }
        return false;
    }

    /**
     * Start the game with the ItemChoice phase.
     */
    public void startGame() {
        this.gameStart = Date.from(Instant.now());
        this.itemChoicePhase.sendOffer();
    }
}
